# 分治

## 设计思想和策略
将一个难以直接解决的大问题, 分割成一些规模较小的相同问题, 以便各个击破, 分而治之.

 对于一个规模为 n 的问题, 若改问题可以容易的解决(比如说规模 n 较小)则直接解决, 否则将其分解为 k 个规模较小的子问题, 这些子问题 
**相互独立且与原问题形式相同**, 递归的解决这些子问题, 然后将各个子问题的解合并的到原问题的解.

## 适用情况
- 该问题的规模缩小到一定的程度就可以容易的解决
- 该问题可以分解为若干个规模较小的相同问题, 即该问题具有 **最优子结构性质**
- 利用该问题分解出的子问题的解可以合并为该问题的解
- 该问题所分解出的各个子问题是**相互独立**的, 即子问题不包含公共的子子问题

第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；

第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；、

第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。

第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。

## 基本步骤
分治法在每一层递归上都有三个步骤
- step1 分解: 将原问题分解为若干个规模较小, 相互独立, 与原问题形式相同的子问题
- step2 解决: 若子问题规模较小而容易解决则直接解, 否则递归的解各个子问题
- step3 合并: 将各个子问题的解合并为原问题的解

## 设计模式
```
Divide-and-Conquer(P):
    if |P| <= n_0
        return ADHOC(P)
    P_1, P2, P_3, ... ,P_k = Divide(P)
    for i in 1 to k:
        y_i = Divide-and-Conquer(P_i)
    T = MERGE(y_1, y_2, y_3, ..., y_k)
    return T  
```

## 复杂性分析

## 常见问题
- 二分搜索
- 大整数乘法
- Strassen矩阵乘法
- 棋盘覆盖
- 合并排序
- 快速排序
- 线性时间选择
- 最接近点对
- 循环赛日程表
- 汉诺塔

## 总结
分治实际上类似与数学上的数学归纳法, 找到解决本问题的求解方程公式, 然后根据方程公式设计递归程序.
- 一定是先找到最小问题规模时的求解方法
- 然后考虑随着问题规模增大时的求解方法
- 找到求解的递归函数式后, 设计递归程序即可


# 动态规划

## 设计思想和策略
将待求解的问题分解为若干个子问题, 按照顺序求解子问题阶段, 前一个子问题的解, 为后一个子问题的求解提供了有用的信息, 在求解任一子问题时, 
列出各种可能的局部解, 通过决策保留那些有可能达到最优的局部解, 丢弃其他局部解. 依次解决各个子问题, 最后一个子问题的解就是原问题的解.

由于动态规划解决的问题多数有重叠子问题这个特点, 为减少重复计算, 对每一个子问题只解一次, 将其不同阶段的不同状态保留在一个二维数组中.

与分治最大的差别是, 适用于动态规划求解的问题, 经分解后, 得到的子问题往往不是相互独立的.

## 适用情况
- 最优原理: 如果问题的最优解包含的子问题的解也是最优的, 就称该问题具有最优子结构, 即满足最优化原理.
- 无后效性: 即某一阶段状态一旦确定, 就不受这个状态之后的决策影响, 也就是说, 某状态以后的过程不会影响以前的状态, 只与当前状态有关.
- 有重叠子问题: 即子问题之间是不独立的, 一个子问题在下一阶段决策中可能被多次使用到.(该性质不是动态规划适用的必要条件, 但如果没有这条
性质, 动态规划算法同其他算法相比就不具备优势)

## 基本步骤

下面以


## 设计模式


## 复杂性分析

## 常见问题


## 总结





































