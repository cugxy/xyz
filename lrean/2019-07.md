# 03
### flask_sqlalchemy 在非 app 上下文访问数据库
```
class Province(db.Model):
    __tablename__ = 'province'
    __table_args__ = {"useexisting": True}
    gb_code = Column(String(6), primary_key=True)                   # 行政编码
    name = Column(String(128), nullable=False)                      # 名称
    geom = Column(Geometry(geometry_type='GEOMETRY', srid=4326))    # 几何字段
    abbreviation = Column(String(128), nullable=False)              # 简称
    pinyin = Column(String(128), nullable=False)                    # 拼音
    description = Column(String(1024), nullable=True)               # 描述

    @staticmethod
    def insert_province(session=db.session):
        root = os.path.split(os.path.realpath(__file__))[0]
        num_file_path = '%s/province/number.txt' % root
        provinces = get_provinces(num_file_path)
        flag = 0
        for number in provinces.keys():
            province = session.query(Province).filter(Province.gb_code == str(number)).one_or_none()
            if province:
                continue
            name = provinces[number]
            _pinyin = lazy_pinyin(name)
            pinyin = ''
            for _ in _pinyin:
                pinyin += _
            abbreviation = name
            flag = 1
            province = Province(gb_code=number, name=name, abbreviation=abbreviation, pinyin=pinyin)
            session.add(province)
        if flag == 0:
            return True
        session.commit()
        shp_file_path = '%s/province/province.shp' % root
        provinces_geom = get_provinces_geom(shp_file_path)
        if not provinces_geom:
            return False
        for number in provinces_geom.keys():
            province = session.query(Province).filter(Province.gb_code == str(number)).one_or_none()
            if province is None:
                continue
            if province.geom is not None:
                continue
            geom_wkb = from_shape(MultiPolygon(provinces_geom[number]), 4326)
            province.geom = geom_wkb
            session.add(province)
        session.commit()
        return True

    @staticmethod
    def get_province_id(gb_code, session=db.session):
        """
        通过 session 访问数据库, 在 app 上下文内, 直接使用 db.session 
        """
        province = session.query(Province).filter(Province.gb_code == str(gb_code)).one_or_none()
        if province is None:
            return None
        return province.id

# file: test
sql = 'postgresql://{username}:{password}@{host}:{port}/{db_name}'.format(username=username, password=password, host=host, port=port, db_name=db_name)
engine = create_engine(sql)
db_session = sessionmaker(bind=self.engine)
session = db_session()

def create_table():
    db.Model.metadata.create_all(engine)    # 传入 engine 创建表
    Role.insert_role(session)               
    User.insert_admin(session)
    Province.insert_province(session)       # 传入 session 访问数据库
    City.insert_city(session)
    create_view(engine)
```

### Qt 多线程计算

# 04
### 拟合直线方程
```
def func_1(x, k, b):
    return k * x + b

popt, pcov = curve_fit(func_1, xy[:, 0], xy[:, 1])
```

### 拟合平面方程(最小二乘)
```
def plane_func(p, points):
    a0, a1, b = p
    return a0 * points[:, 0] + a1 * points[:, 1] - b

def plane_errors(p, points):
    """平面误差"""
    return plane_func(p, points) - points[:, 2]

p0 = [1, 1, 1, ]

para=leastsq(plane_errors, p0, args=(points, ))
a0, a1, b = para[0]
n = np.array([a0, a1, -1])      
n = n / np.linalg.norm(n)   # 法向量
```

### 多元方程求解
```
# ax^2 + bx + c = y

X = np.array([[e[0] * e[0], e[0], 1] for e in xy])
Y = np.array([e[1] for e in xy])
r1 = solve(X, Y)
a = r1[0]
b = r1[1]
c = r1[2]
```