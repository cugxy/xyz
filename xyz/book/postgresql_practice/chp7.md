# 事务与并发控制
数据库的并发控制系统引入了 基于锁的并发控制机制(Lock-Based Concurrency Control) 和 基于多版本的并发控制机制 MVCC(Multi-Version Concurrency Control)

## 事务与并发概念
事务时数据库系统执行过程中最小的逻辑单位. 当事务被提交时, 数据库管理系统药确保一个事务中的所有操作都成功完成, 并且在数据库中永久保存操作结果. 如果一个事务中的一部分操作没有成功完成, 则数据库管理系统会把数据库回滚到操作执行之前的状态.

- 原子性: 一个事务的所有操作, 要么全部执行, 要么全部不执行, 由事务管理器和 MVCC 控制
- 一致性: 执行事务时保存数据库从一个一致的状态变更到另一个一致的状态, 由主键,外键这类约束保证
- 隔离性: 即使每个事务都能确保一致性和原子性, 如果并发执行时, 由于它们的操作以人们不希望的方式交叉运行, 就会导致不一致的情况发生. 确保事务与事务并发执行时, 每个事务都感觉不到有其他事务在并发的执行,  由事务管理器和 MVCC 控制
- 持久性: 一个事务完成后, 即使数据库发生故障, 他对数据库的改变应该永久保存在数据库中, 由预写日志和数据库管理系统的恢复子系统保证

### 并发引起现象
- 脏读: Dirty read 当事务A 读取了事务B 中已经修改但还未提交的数据, 包括 insert, update, delete, 当事务B 不提交并执行 rollback 后, 事务A 所读到的数据时不正确的, 即为 脏读.
- 不可重复读: Non-repeatable read 当事务A 第一次读取数据之后, 被读取的数据被已提交的事务B 进行了修改, 事务A 再次读取这些数据时发现数据已被事务B 修改, 两次查询结果不一致, 即为 不可重复读
- 幻读: Phantom read 指一个事务两次查询的结果集记录数不一致, 如 事务A 根据范围条件查询一些数据, 事务B 却在此时插入或删除了部分数据, 事务A 在接下来的查询中, 会发现有些数据与之前查询结果不一致, 即为 幻读, 幻读可以认为是受 INSERT 和 DELETE 影响的 不可重复读 的一种特殊场景.
- 序列化异常: Serialization anomaly 指成功提交的一组事务的执行结果与这些事务按照串行执行方式的执行结果不一致.

### ANSI SQL 标准的事务隔离级别

为了避免事务之间并发执行的副作用, ANSI SQL 标准定义了四类隔离级别.

- Read Uncommitted: 所有事务都可以看到其他未提交事务的执行结果. 
- Read Committed: 满足一个事务只能看见已经提交事务对关联数据所做的改变的隔离需求.
- Repeatable Read: 确保同一事务的多个实例在并发读取数据时, 会看到同样的数据行.
- Serializable: 每个读取数据上加上共享锁.

### PostgreSQL 事务隔离级别
SQL 标准定义的四种隔离级别只定义了哪种现象不能发送, 描述了每种隔离级别必须提供的最小保护, 但是没有定义哪种现象必须发生. 因此在PostgreSQL 中只实现了三种不同的隔离级别:
- Read Uncommitted 与 Read Committed 一致
- Repeatable Read 不允许出现幻读
- Serializable 不允许序列化异常