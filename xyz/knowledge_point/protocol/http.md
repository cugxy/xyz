# Http 协议

> http 协议是 Hyper Text Transfer Protocol(超文本传输协议)的缩写, 用于万维网(World Wide Web)服务器传输超文本到本地浏览器的传送协议.

- http 基于 TCP/IP 通信协议来传输数据.
- http 是一个属于应用层的面向对象的协议
- 默认使用 80 端口

## 历史版本

### HTTP/0.9
只有 GET 命令, 服务器回应只有 HTML 格式的字符串.

### HTTP/1.0
#### 介绍
可发送任何格式内容, 包括文字, 图像,视频,二进制文件等.支持 GET, POST, HEAD 命令,

请求和回应格式改变, 除数据部分, 每次通信必须包含头信息(HTTP header), 用来描述元数据

添加 状态码(status code), 多字符集支持, 多部分发送(multi-part type), 权限(authorization), 缓存(cache), 内容编码(content encoding)
 
#### 请求格式
```
GET / HTTP/1.0
User-Agent: Mozilla/5.0(Macontosh: Intel Mac OS X 10_10_5)
Accpt: */*
```

第一行是请求命令, 必须在尾部添加协议版本(HTTP/1.0). 后面为多行头信息, 描述客户端情况.

#### 回应格式
```
HTTP/1.0 200 OK 
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

<html>
  <body>Hello World</body>
</html>
```
头信息 + 空行(`\r\n`) + 数据, 其中,第一行为协议版本 + 状态码 + 状态描述

#### Content-Type 字段
 1.0 版本规定, 头信息必须是 ASCII 码, 后面的数据可以是任何形式.因此,服务器回应时,必须高速客户端数据格式
 
 常见 Content-Type 字段值

- text/plain
- text/html
- text/css
- image/jpeg
- image/png
- image/svg+xml
- audio/mp4
- video/mp4
- application/javascript
- application/pdf
- application/zip
- application/atom+xml

这些数据类型总称为 MIME type, 每个值包括一级类型和二级类型, 之间用斜杠分隔. 除了以上预定义类型, 厂商也可自定义类型.
 
`application/vnd.debian.binary-package(Debian系统的二进制数据包)`

MIME type 还可以在尾部使用分号添加参数

`Content-Type:text/html; charset=utf-8(UTF-8编码的网页)`

客户端请求时可以使用 Accept 字段表明自己可以接收哪些数据格式

#### Content-Encoding 字段
Content-Encoding 用于说明发送的数据的压缩方法, 支持如下
- gzip
- compress
- deflate

客户端请求时,也可使用 Accept-Encoding 说明可接受的压缩方法

`Accept-Encoding: gzip, deflate`

#### 缺点
- 每个 TCP 连接只能发送一个请求, 发送数据完毕, 连接就关闭, 如果还需要请求其他资源, 就必须再新建一个连接. TCP连接的新建成本很高, 因为
需要客户端和服务器三次握手, 并且开始时发送速率较慢(@todo 说明为啥较慢).所以 HTTP/1.0性能较差, 为解决这个问题, 有些浏览器在请求时, 
用了一个非标准的 `Connection` 字段

```
Connection: keep-alive
```
此字段要求服务器不要关闭 TCP 连接, 以便其他请求复用, 服务器同样回应此字段
```
Connection: keep-alive
```
一个可复用的 TCP 连接就建立了, 直到客户端或服务器朱永关闭连接. 但这不是标准字段, 不同实现的行为可能不一致, 因此不是根本的解决办法.


### HTTP/1.1
1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。

#### 持续连接
默认 TCP 连接不关闭, 可以被多个请求复用, 不用声明 `Connection: keep-alive`, 客户端服务器发现对方一段时间没有活动, 就主动关闭连接.
规范做法为, 客户端在最后一个请求时, 发送 Connection: close, 明确要求服务器关闭 TCP 连接.

> 注意对于同一个域名, 大多数浏览器允许同时建立 6 个持久连接.

#### 管道机制
同一个 TCP 连接里面, 客户端可以同时发送多个请求, 服务器依然按照顺序返回

HTTP Pipelining其实是把多个HTTP请求放到一个TCP连接中一一发送，而在发送过程中不需要等待服务器对前一个请求的响应；只不过，客户端还是要按照发送请求的顺序来接收响应。如果前一个请求非常耗时, 那么后续请求都会受到影响, 这就是所谓的线头阻塞(Head of line blocking). 当然，你可以在选择队伍时候就做好功课，去排一个你认为最快的队伍，或者甚至另起一个新的队伍（译者注：即新建一个TCP连接）。但不管怎么样，你总归得先选择一个队伍，而且一旦选定之后，就不能更换队伍。但是，另起新队伍会导致资源耗费和性能损失（译者注：新建 TCP 连接的开销非常大）。这种另起新队伍的方式只在新队伍数量很少的情况下有作用，因此它并不具备可扩展性。（译者注：这段话意思是说，靠大量新建连接是不能有效解决延迟问题的，即HTTP Pipelining并不能彻底解决Head ofline blocking问题。）所以针对此问题并没有完美的解决方案。

>这也是大部分桌面浏览器仍然会选择默认关闭HTTP pipelining这一功能的原因。

#### Content-Length 字段
一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。
```
Content-Length: 3495
```
上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。
在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。

#### 分块传输编码
使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。
对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，
就发送一块，采用"流模式"（stream）取代"缓存模式"（buffer）。

因此，1.1版规定可以不使用Content-Length字段，而使用"分块传输编码"（chunked transfer encoding）。
只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。
```
Transfer-Encoding: chunked
```
每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。

```
HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

25
This is the data in the first chunk

1C
and this is the second one

3
con

8
sequence

0
```

#### 其他功能

- 支持方法包括 GET(0.9版本添加), POST(1.0版本添加), HEAD(1.0版本添加), PUT, DELETE, PATCH, OPTIONS

- 客户端请求头添加 Host 子段, 用来指定服务器域名 `Host: www.example.com` 有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。

#### 缺点
虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为线头阻塞(Head of line blocking)。

为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。


### HTTP/2
2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。

#### 二进制协议
HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，
头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。

二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，
解析数据将会变得非常麻烦，二进制解析则方便得多。

#### 多工/多路复用
HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了线头阻塞(Head of line blocking)。

举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 
接着回应B请求，完成后，再发送A请求剩下的部分。

这样双向的、实时的通信，就叫做多工（Multiplexing）。

#### 数据流
因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。

HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，
用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。

数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。
这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。

客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。

#### 头信息压缩
HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。

HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；
另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

#### 服务器推送
HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。

常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。
其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

### 常见方法

#### GET

GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。

GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。

#### HEAD

HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。

#### POST

POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。

#### PUT

PUT请求会身向指定资源位置上传其最新内容，PUT方法是[幂等](https://zh.wikipedia.org/wiki/%E5%86%AA%E7%AD%89)的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。

#### DELETE

DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。

#### CONNECT

CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。

#### OPTIONS

OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用'*'来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许

#### TRACE

TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。

#### PATCH

PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：

但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。
当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。

